{"path":".obsidian/plugins/text-extractor/cache/pa/Pasted image 20230401224252.png-ff1cb50beb01ff9c473e477ed7cbbc94.json","text":"Example 5.5. Suppose our list contains n integers between 0 and 999 inclusive. Using b = 1000 results in essentially a single iteration of CountingSort with k = max = 999 which requires n + k + n + n = 3n + 999 iterations as per the loop structure in CountingSort. On the other hand using b = 10 results in three iterations of CountingSort with k¥ = maxz = 9 each requiring n+k+n+n = 3n+9 iterations for a total of 3(3n + 9) = 9n + 27 iterations within CountingSort. Depending on the time requirements inside the loops it’s entirely possible that the second is quicker for some n. For example if each iteration within Count- ingSort took time 1 then 9n + 30 < 3n + 1000 when n < 162 so for small lists it’s definitely the case that RadixSort+CountingSort is better than just using a huge base.","libVersion":"0.0.0","langs":"eng","hash":"","size":0}